{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./types.ts","webpack:///external \"lodash\"","webpack:///./utils.ts","webpack:///./module.ts","webpack:///./datasource.ts","webpack:///./cache.ts","webpack:///./parser.ts","webpack:///./query_ctrl.ts","webpack:///external \"app/plugins/sdk\"","webpack:///./css/query_editor.css?f712","webpack:///./css/query_editor.css","webpack:///../node_modules/css-loader/dist/runtime/api.js","webpack:///../node_modules/style-loader/lib/addStyles.js","webpack:///../node_modules/style-loader/lib/urls.js","webpack:///./config_ctrl.ts","webpack:///./annotation_ctrl.ts","webpack:///./variable_query_ctrl.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Tab","ParseType","isError","maybeError","undefined","error","FilterType","__WEBPACK_EXTERNAL_MODULE__1__","lodash_1","__importDefault","types_1","Utils","getQueryString","obj","default","reduce","result","val","isNil","isArray","map","encodeURIComponent","join","slice","getDatasourceValueString","aggregation","","none","avg","int","stepinterpolation","step","continuousvariance","continuousVariance","cv","discretevariance","dv","totalvariation","tv","getAggregationDropdownString","splitFilters","filterString","filtersOptions","onlyAllowEquals","filterStrings","openChars","closeChars","start","length","filter","substring","trim","match","indexOf","push","findIndex","x","c_1","out_i_1","applyFilters","filters","objects","_i","objects_1","selected","_a","filters_1","type","RegexEquals","regex","RegexNotEquals","NotEquals","String","Equals","intervalToGranularity","intervalMs","seconds","Math","round","minutes","hours","timeseriesHash","options","target","dashboardId","panelId","refId","assetQuery","templatedTarget","includeSubtrees","datasource_1","Datasource","query_ctrl_1","QueryCtrl","CogniteQueryCtrl","config_ctrl_1","ConfigCtrl","CogniteConfigCtrl","annotation_ctrl_1","AnnotationsQueryCtrl","CogniteAnnotationsQueryCtrl","variable_query_ctrl_1","VariableQueryEditor","CogniteVariableQueryCtrl","dateMath","__importStar","utils_1","cache_1","parser_1","CogniteDatasource","instanceSettings","backendSrv","templateSrv","this","id","url","project","jsonData","cogniteProject","$inject","queryTargets","targets","warning","hide","tab","Timeseries","Asset","Custom","concat","Promise","resolve","data","timeFrom","ceil","parse","range","from","timeTo","to","targetQueriesCount","labels","dataQueryRequestPromises","queryTargets_1","getDataQueryRequestItems","dataQueryRequestItems","_d","sent","qlChunks","chunk","queryList","qlChunks_1","qlChunk","count","queryReq","items","end","aggregates","granularity","function","idsCount","idRegex","qlChunk_1","q","matches","idsObj","_b","matches_1","substr","keys","usesAggregates","some","item","aliases","limit","floor","queries","label","trys","this_1","getTimeseries","ts","timeseries","forEach","_this","getTimeseriesLabel","count_1","ql","_c","queryRequests","getQuery","method","catch","datapoints","response","find","errmsg","status","message","config","aggregationPrefix","timestamp","expr","parseExpression","e","annotation","startTime","endTime","queryOptions","Event","console","filterOptions","queryParams","__assign","maxStartTime","minEndTime","events","event","isRegion","text","description","time","timeEnd","title","__generator","urlEnd","query","then","timeSeriesResponseItem","assetId","replace","scopedVars","searchQuery","path","ts_1","setTimeseries","old","splice","cloneDeep","isString","assets","asset","full","group","testDatasource","datasourceRequest","loggedIn","results","Map","requests","stringQuery","JSON","stringify","has","promise","res","set","setTimeout","delete","assetTimeseries","cache","trimmedExpr","isSimpleTimeseriesExpression","getAndApplyFilterOptions","exprWithSpecialFunctions","parseSpecialFunctions","createDataQueryRequestItems","newExpr","funcRegexMatches","_loop_1","matchIndex","timeseriesString","findTimeseriesString","charAt","actualMatchString","selectedTs","funcString","toLowerCase","getTempAliasString","funcRegexMatches_1","dataItems","selectedTs_1","replaceString","tsFiltersString","index","similarTimeseriesString","similarFilterOptions","updateAliases","withAggregateAndGranularity","timeseriesIndex","startIndex","openBracketCount","endQuote","closeBracketIndex","queryItem","regexMatches","_loop_2","aliasParts","split","string","alias","Number","aggregate","regexMatches_1","customQuery","variables","templateVariable","current","splitfilters","timeseriesMatch","assetMatch","filterMatch","splitfilters_1","f","splitAggregation","sdk_1","_super","$scope","$injector","tabs","src","defaults","func","defaultsDeep","currentTabIndex","isAllSelected","every","__extends","getOptions","datasource","getOptionsForDropdown","defer","$digest","onChangeInternal","refresh","changeTab","toggleCheckboxes","selectOption","getCollapsedText","templateUrl","content","hmr","insertInto","locals","list","toString","useSourceMap","cssMapping","btoa","sourceMapping","sourceMap","unescape","sourceURLs","sources","source","sourceRoot","cssWithMappingToString","mediaQuery","alreadyImportedModules","memo","stylesInDom","isOldIE","fn","apply","arguments","parent","styleTarget","querySelector","window","HTMLIFrameElement","contentDocument","head","singleton","stylesInsertedAtTop","fixUrls","addStylesToDom","styles","domStyle","refs","j","parts","addStyle","listToStyles","newStyles","base","part","css","media","getElement","lastStyleElementInsertedAtTop","insertAt","nextSibling","insertBefore","style","appendChild","firstChild","before","Error","removeStyleElement","parentNode","removeChild","idx","document","createElement","attrs","nonce","getNonce","insertStyleElement","addAttrs","el","setAttribute","update","remove","transform","styleIndex","singletonCounter","createStyleElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","link","rel","createLinkElement","autoFixUrls","convertToAbsoluteUrls","blob","oldSrc","href","styleSheet","cssText","createTextNode","newObj","DEBUG","mayRemove","newList","textStore","replacement","Boolean","replaceText","childNodes","cssNode","location","currentDir","baseUrl","pathname","fullMatch","origUrl","newUrl","unquotedOrigUrl","$1","test","mod","verify","errorObj","react_1","props","state","assign","handleChange","prop","setState","handleBlur","onChange","render","className","onBlur","placeholder","required"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import {\n  DataQueryOptions,\n  DataQuery,\n  TimeSeries,\n  TimeRange,\n  RawTimeRange,\n  DataSourceSettings,\n} from '@grafana/ui';\n\nexport interface QueryResponse {\n  data: TimeSeries[];\n}\n\nexport interface MetricDescription {\n  readonly text: string;\n  readonly value: number | string;\n}\n\nexport type MetricFindQueryResponse = MetricDescription[];\n\nexport enum Tab {\n  Timeseries = 'Timeseries',\n  Asset = 'Asset',\n  Custom = 'Custom',\n}\n\nexport enum ParseType {\n  Timeseries = 'Timeseries',\n  Asset = 'Asset',\n  Event = 'Event',\n}\n\nexport interface TimeSeriesResponseItem {\n  name: string;\n  isString?: boolean;\n  metadata?: object;\n  unit?: string;\n  assetId?: string;\n  isStep: boolean;\n  description?: string;\n  source?: string;\n  sourceId?: string;\n  id: number;\n  createdTime: number;\n  lastUpdatedTime: number;\n  selected: boolean;\n}\n\nexport interface TimeSeriesResponse {\n  data: {\n    items: TimeSeriesResponseItem[];\n  };\n}\n\nexport interface AssetQuery {\n  target: string;\n  includeSubtrees: boolean;\n  old?: AssetQuery;\n  timeseries?: TimeSeriesResponseItem[];\n  func?: string;\n  templatedTarget?: string;\n}\n\nexport interface QueryTarget extends DataQuery {\n  target: string;\n  aggregation: string;\n  granularity: string;\n  error: string;\n  label: string;\n  tab: Tab;\n  assetQuery: AssetQuery;\n  expr: string;\n  warning: string;\n}\n\nexport type QueryFormat = 'json';\n\nexport type QueryOptions = DataQueryOptions<QueryTarget>;\n\nexport type HttpMethod = 'POST' | 'GET' | 'PATCH' | 'DELETE';\n\nexport interface DataSourceRequestOptions {\n  url: string;\n  method: HttpMethod;\n  retry?: number;\n  requestId?: string;\n  headers?: { [s: string]: string };\n  silent?: boolean;\n  data?: DataQueryRequest;\n}\n\nexport interface TimeSeriesDatapoint {\n  timestamp: number;\n  value: string;\n}\n\nexport interface Datapoint {\n  name: string;\n  datapoints: TimeSeriesDatapoint[];\n}\n\nexport interface Datapoints {\n  items: Datapoint[];\n}\n\nexport interface DataDatapoints {\n  data: Datapoints;\n}\n\nexport interface DataQueryRequestResponse {\n  data: DataDatapoints;\n  config: {\n    data: {\n      aggregates: string;\n      limit: number;\n    };\n  };\n}\n\nexport type DataQueryError = {\n  error: {\n    data: {\n      error?: {\n        message: string;\n        notFound?: string[];\n      };\n    };\n    status: number;\n  };\n};\n\nexport function isError(maybeError: DataQueryError | any): maybeError is DataQueryError {\n  return (<DataQueryError>maybeError).error !== undefined;\n}\n\nexport interface DataQueryAlias {\n  alias: string;\n  id: number;\n  aggregate?: string;\n  granularity?: string;\n}\n\nexport interface DataQueryRequestItem {\n  name: string;\n  start?: string | number;\n  end?: string | number;\n  limit?: number;\n  granularity?: string;\n  aggregates?: string;\n  function?: string;\n  aliases?: DataQueryAlias[];\n}\n\nexport interface DataQueryRequest {\n  items: DataQueryRequestItem[];\n  start: string | number;\n  end: string | number;\n  limit?: number;\n  aggregates?: string;\n  granularity?: string;\n}\n\nexport interface Annotation {\n  datasource: string;\n  enable: boolean;\n  hide: boolean;\n  iconColor: string;\n  limit: number;\n  name: string;\n  expr: string;\n  filter: string;\n  error: string;\n  type: string;\n  tags: string[];\n}\n\nexport interface AnnotationQueryOptions {\n  range: TimeRange;\n  rangeRaw: RawTimeRange;\n  annotation: Annotation;\n  dashboard: number;\n}\n\nexport interface AnnotationResponse {\n  annotation: Annotation;\n  title: string;\n  time: number;\n  timeEnd?: number;\n  text: string;\n  tags?: string[];\n  isRegion?: boolean;\n}\n\nexport interface AnnotationSearchQuery {\n  description: string;\n  type: string;\n  subtype: string;\n  minStartTime: number;\n  maxStartTime: number;\n  minEndTime: number;\n  maxEndTime: number;\n  minCreatedTime: number;\n  maxCreatedTime: number;\n  minLastUpdatedTime: number;\n  maxLastUpdatedTime: number;\n  // format is {\"k1\": \"v1\", \"k2\": \"v2\"}\n  metadata: string;\n  assetIds: number[];\n  assetSubtrees: number[];\n  sort: 'startTime' | 'endTime' | 'createdTime' | 'lastUpdatedTime';\n  dir: 'asc' | 'desc';\n  limit: number;\n  offset: 0;\n}\n\nexport interface Event {\n  id: number;\n  startTime: number;\n  endTime: number;\n  description: string;\n  type: string;\n  subtype: string;\n  assetIds: number[];\n  source: string;\n  sourceId: string;\n}\n\nexport interface Events {\n  items: Event[];\n}\n\nexport interface DataEvents {\n  data: Events;\n}\n\nexport interface AnnotationQueryRequestResponse {\n  data: DataEvents;\n}\n\nexport interface TimeseriesSearchQuery {\n  q: string;\n  description: string;\n  limit: number;\n  includeMetadata: boolean;\n  path: string[];\n  assetId: string;\n}\n\nexport interface VariableQueryData {\n  query: string;\n  filter: string;\n}\n\nexport interface VariableQueryProps {\n  query: any;\n  onChange: (query: any, definition: string) => void;\n  datasource: any;\n  templateSrv: any;\n}\n\nexport interface CogniteDataSourceSettings extends DataSourceSettings {\n  jsonData: {\n    authType: string;\n    defaultRegion: string;\n    cogniteProject: string;\n  };\n}\n\nexport enum FilterType {\n  Equals = '=',\n  NotEquals = '!=',\n  RegexEquals = '=~',\n  RegexNotEquals = '!~',\n}\n\nexport interface Filter {\n  property: string;\n  value: string;\n  type: FilterType;\n}\n\nexport interface FilterOptions {\n  filters: Filter[];\n  granularity: string;\n  aggregation: string;\n  error: string;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","import _ from 'lodash';\nimport { Filter, FilterType, QueryOptions, QueryTarget } from './types';\n\nexport default class Utils {\n  // Converts an object to a query string, ignores properties with undefined/null values\n  // TODO: maybe clean this up a bit, might break easily\n  static getQueryString(obj: any) {\n    return _.reduce(\n      obj,\n      (result: string, val: any, key: string) => {\n        return _.isNil(val)\n          ? result\n          : _.isArray(val)\n          ? `${result + [key, val].map(encodeURIComponent).join('=[')}]&`\n          : `${result + [key, val].map(encodeURIComponent).join('=')}&` + '';\n      },\n      ''\n    ).slice(0, -1);\n  }\n\n  static getDatasourceValueString(aggregation: string): string {\n    const mapping = {\n      '': 'value',\n      undefined: 'value',\n      none: 'value',\n      avg: 'average',\n      int: 'interpolation',\n      stepinterpolation: 'stepInterpolation',\n      step: 'stepInterpolation',\n      continuousvariance: 'continousVariance', // spelling mistake is intended - will have to change in 0.6\n      continuousVariance: 'continousVariance',\n      cv: 'continousVariance',\n      discretevariance: 'discreteVariance',\n      dv: 'discreteVariance',\n      totalvariation: 'totalVariation',\n      tv: 'totalVariation',\n    };\n    return mapping[aggregation] || aggregation;\n  }\n\n  static getAggregationDropdownString(aggregation: string): string {\n    let val = Utils.getDatasourceValueString(aggregation);\n    if (val === 'continousVariance') val = 'continuousVariance';\n    // temp 0.5 fix\n    else if (val === 'value') val = 'none';\n    return val;\n  }\n\n  static splitFilters(filterString: string, filtersOptions: any, onlyAllowEquals: boolean) {\n    const filterStrings = [];\n    // ignore commas that are within these characters\n    const openChars = ['(', '[', '{', \"'\", '\"'];\n    const closeChars = [')', ']', '}', \"'\", '\"'];\n    let start = 0;\n    for (let i = 0; i <= filterString.length; ++i) {\n      if (i === filterString.length || filterString[i] === ',') {\n        const filter = filterString.substring(start, i).trim();\n        if (filter.length === 0) {\n          start = i + 1;\n          continue;\n        }\n        if (onlyAllowEquals && !filter.match(/[^!]=[^~]/)) {\n          filtersOptions.error = `ERROR: Unable to parse '${filter}'. Only strict equality (=) is allowed.`;\n          return undefined;\n        }\n        if (filter.indexOf('=') === -1 && filter.indexOf('~') === -1) {\n          filtersOptions.error = `ERROR: Could not parse: '${filter}'. Missing a comparator (=,!=,=~,!~).`;\n          return undefined;\n        }\n        filterStrings.push(filter);\n        start = i + 1;\n        continue;\n      }\n      const o = openChars.findIndex(x => x === filterString[i]);\n      if (o >= 0) {\n        const c = filterString.indexOf(closeChars[o], i + 1);\n        if (c >= 0) {\n          i = c;\n          continue;\n        } else {\n          filtersOptions.error = `ERROR: Could not find closing ' ${\n            closeChars[o]\n          } ' while parsing '${filterString.substring(start)}'.`;\n          return undefined;\n        }\n      }\n      const c = closeChars.findIndex(x => x === filterString[i]);\n      if (c >= 0) {\n        filtersOptions.error = `ERROR: Unexpected character ' ${\n          closeChars[c]\n        } ' while parsing '${filterString.substring(start)}'.`;\n        return undefined;\n      }\n    }\n    return filterStrings;\n  }\n\n  static applyFilters(filters: Filter[], objects: any): void {\n    for (const obj of objects) {\n      obj.selected = true;\n      for (const filter of filters) {\n        if (filter.type === FilterType.RegexEquals) {\n          const val = _.get(obj, filter.property);\n          const regex = `^${filter.value}$`;\n          if (val === undefined || !val.match(regex)) {\n            obj.selected = false;\n            break;\n          }\n        } else if (filter.type === FilterType.RegexNotEquals) {\n          const val = _.get(obj, filter.property);\n          const regex = `^${filter.value}$`;\n          if (val === undefined || val.match(regex)) {\n            obj.selected = false;\n            break;\n          }\n        } else if (filter.type === FilterType.NotEquals) {\n          const val = _.get(obj, filter.property);\n          if (val === undefined || String(val) === filter.value) {\n            obj.selected = false;\n            break;\n          }\n        } else if (filter.type === FilterType.Equals) {\n          const val = _.get(obj, filter.property);\n          if (val === undefined || String(val) !== filter.value) {\n            obj.selected = false;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  static intervalToGranularity(intervalMs: number): string {\n    const seconds = Math.round(intervalMs / 1000.0);\n    if (seconds <= 60) {\n      if (seconds <= 1) {\n        return '1s';\n      }\n      return `${seconds}s`;\n    }\n    const minutes = Math.round(intervalMs / 1000.0 / 60.0);\n    if (minutes < 60) {\n      return `${minutes}m`;\n    }\n    const hours = Math.round(intervalMs / 1000.0 / 60.0 / 60.0);\n    if (hours <= 24) {\n      return `${hours}h`;\n    }\n    const days = Math.round(intervalMs / 1000.0 / 60.0 / 60.0 / 24.0);\n    return `${days}d`;\n  }\n\n  static timeseriesHash(options: QueryOptions, target: QueryTarget) {\n    return `${options.dashboardId}_${options.panelId}_${target.refId}_${\n      target.assetQuery.templatedTarget\n    }_${target.assetQuery.includeSubtrees}`;\n  }\n}\n","import CogniteDatasource from './datasource';\nimport { CogniteQueryCtrl } from './query_ctrl';\nimport { CogniteConfigCtrl } from './config_ctrl';\nimport { CogniteAnnotationsQueryCtrl } from './annotation_ctrl';\nimport { CogniteVariableQueryCtrl } from './variable_query_ctrl';\n\nexport {\n  CogniteDatasource as Datasource,\n  CogniteQueryCtrl as QueryCtrl,\n  CogniteConfigCtrl as ConfigCtrl,\n  CogniteAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n  CogniteVariableQueryCtrl as VariableQueryEditor,\n};\n","import _ from 'lodash';\nimport * as dateMath from 'grafana/app/core/utils/datemath';\nimport Utils from './utils';\nimport cache from './cache';\nimport { parseExpression, parse } from './parser';\nimport { BackendSrv } from 'grafana/app/core/services/backend_srv';\nimport { TemplateSrv } from 'grafana/app/features/templating/template_srv';\nimport {\n  AnnotationQueryOptions,\n  AnnotationResponse,\n  CogniteDataSourceSettings,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryRequestItem,\n  DataQueryRequestResponse,\n  MetricFindQueryResponse,\n  ParseType,\n  QueryOptions,\n  QueryResponse,\n  QueryTarget,\n  Tab,\n  TimeSeriesResponse,\n  TimeSeriesResponseItem,\n  TimeseriesSearchQuery,\n  VariableQueryData,\n  isError,\n} from './types';\n\nexport default class CogniteDatasource {\n  id: number;\n  url: string;\n  name: string;\n  project: string;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: CogniteDataSourceSettings,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    this.id = instanceSettings.id;\n    this.url = instanceSettings.url;\n    this.project = instanceSettings.jsonData.cogniteProject;\n    this.name = instanceSettings.name;\n  }\n\n  public async query(options: QueryOptions): Promise<QueryResponse> {\n    const queryTargets: QueryTarget[] = options.targets.reduce((targets, target) => {\n      target.error = '';\n      target.warning = '';\n      if (\n        !target ||\n        target.hide ||\n        ((target.tab === Tab.Timeseries || target.tab === undefined) &&\n          (!target.target || target.target === 'Start typing tag id here')) ||\n        ((target.tab === Tab.Asset || target.tab === Tab.Custom) &&\n          (!target.assetQuery || target.assetQuery.target === ''))\n      ) {\n        return targets;\n      }\n      return targets.concat(target);\n    }, []);\n\n    if (queryTargets.length === 0) {\n      return Promise.resolve({ data: [] });\n    }\n\n    const timeFrom = Math.ceil(dateMath.parse(options.range.from));\n    const timeTo = Math.ceil(dateMath.parse(options.range.to));\n    const targetQueriesCount = [];\n    const labels = [];\n\n    const dataQueryRequestPromises: Promise<DataQueryRequestItem[]>[] = [];\n    for (const target of queryTargets) {\n      dataQueryRequestPromises.push(this.getDataQueryRequestItems(target, options));\n    }\n    const dataQueryRequestItems = await Promise.all(dataQueryRequestPromises);\n\n    const queries: DataQueryRequest[] = [];\n    for (const { target, queryList } of dataQueryRequestItems.map((ql, i) => ({\n      target: queryTargets[i],\n      queryList: ql,\n    }))) {\n      if (queryList.length === 0 || target.error) {\n        continue;\n      }\n\n      // /dataquery is limited to 100 items, so we need to add new calls if we go over 100 items\n      // may want to change how much we split into, but for now, 100 seems like the best\n      const qlChunks = _.chunk(queryList, 100);\n      for (const qlChunk of qlChunks) {\n        // keep track of target lengths so we can assign errors later\n        targetQueriesCount.push({\n          refId: target.refId,\n          count: qlChunk.length,\n        });\n        // create query requests\n        const queryReq: DataQueryRequest = {\n          items: qlChunk,\n          start: timeFrom,\n          end: timeTo,\n        };\n        if (target.aggregation && target.aggregation !== 'none') {\n          queryReq.aggregates = target.aggregation;\n          if (!target.granularity) {\n            queryReq.granularity = Utils.intervalToGranularity(options.intervalMs);\n          } else {\n            queryReq.granularity = target.granularity;\n          }\n        }\n        if (target.tab === Tab.Custom && qlChunk[0].function) {\n          let idsCount = 0;\n          const idRegex = /\\[.*?\\]/g; // look for [something]\n          for (const q of qlChunk) {\n            const matches = q.function.match(idRegex);\n            if (!matches) break;\n            const idsObj = {};\n            for (const match of matches) {\n              idsObj[match.substr(1, match.length - 2)] = true;\n            }\n            idsCount += Object.keys(idsObj).length;\n          }\n          if (idsCount === 0) idsCount = 1; // will fail anyways, just show the api error message\n\n          // check if any aggregates are being used\n          const usesAggregates = qlChunk.some(item => item.aliases.length > 0);\n\n          queryReq.limit = Math.floor((usesAggregates ? 10_000 : 100_000) / idsCount);\n        } else {\n          queryReq.limit = Math.floor((queryReq.aggregates ? 10_000 : 100_000) / qlChunk.length);\n        }\n        queries.push(queryReq);\n      }\n\n      // assign labels to each timeseries\n      if (target.tab === Tab.Timeseries || target.tab === undefined) {\n        if (!target.label) target.label = '';\n        if (target.label.match(/{{.*}}/)) {\n          try {\n            // need to fetch the timeseries\n            const ts = await this.getTimeseries(\n              {\n                q: target.target,\n                limit: 1,\n              },\n              target\n            );\n            labels.push(this.getTimeseriesLabel(target.label, ts[0]));\n          } catch {\n            labels.push(target.label);\n          }\n        } else {\n          labels.push(target.label);\n        }\n      } else if (target.tab === Tab.Asset) {\n        target.assetQuery.timeseries.forEach(ts => {\n          if (ts.selected) {\n            if (!target.label) target.label = '';\n            labels.push(this.getTimeseriesLabel(target.label, ts));\n          }\n        });\n      } else {\n        let count = 0;\n        while (count < queryList.length) {\n          cache.getTimeseries(options, target).forEach(ts => {\n            if (ts.selected && count < queryList.length) {\n              count += 1;\n              if (!target.label) {\n                if (queryList[0].function) {\n                  // if using custom functions and no label is specified just use the name of the last timeseries in the function\n                  labels.push(ts.name);\n                  return;\n                }\n                target.label = '';\n              }\n              labels.push(this.getTimeseriesLabel(target.label, ts));\n            }\n          });\n        }\n      }\n    }\n\n    const queryRequests = queries.map(q =>\n      cache\n        .getQuery(\n          {\n            url: `${this.url}/cogniteapi/${this.project}/timeseries/dataquery`,\n            method: 'POST',\n            data: q,\n          },\n          this.backendSrv\n        )\n        .catch(error => {\n          return { error };\n        })\n    );\n\n    let timeseries: (DataQueryRequestResponse | DataQueryError)[];\n    try {\n      timeseries = await Promise.all(queryRequests);\n    } catch (error) {\n      return { data: [] };\n    }\n    let count = 0;\n    return {\n      data: timeseries.reduce((datapoints, response, i) => {\n        const refId = targetQueriesCount[i].refId;\n        const target = queryTargets.find(x => x.refId === refId);\n        if (isError(response)) {\n          let errmsg: string;\n          if (response.error.data && response.error.data.error) {\n            errmsg = `[${response.error.status} ERROR] ${response.error.data.error.message}`;\n          } else {\n            errmsg = 'Unknown error';\n          }\n          target.error = errmsg;\n          count += targetQueriesCount[i].count; // skip over these labels\n          return datapoints;\n        }\n\n        const aggregation = response.config.data.aggregates;\n        const aggregationPrefix = aggregation ? `${aggregation} ` : '';\n        return datapoints.concat(\n          response.data.data.items.map(item => {\n            if (item.datapoints.length >= response.config.data.limit) {\n              target.warning =\n                '[WARNING] Datapoints limit was reached, so not all datapoints may be shown. Try increasing the granularity, or choose a smaller time range.';\n            }\n            return {\n              target: labels[count++] ? labels[count - 1] : aggregationPrefix + item.name,\n              datapoints: item.datapoints\n                .filter(d => d.timestamp >= timeFrom && d.timestamp <= timeTo)\n                .map(d => {\n                  const val = Utils.getDatasourceValueString(response.config.data.aggregates);\n                  return [d[val] === undefined ? d.value : d[val], d.timestamp];\n                }),\n            };\n          })\n        );\n      }, []),\n    };\n  }\n\n  private async getDataQueryRequestItems(\n    target: QueryTarget,\n    options: QueryOptions\n  ): Promise<DataQueryRequestItem[]> {\n    if (target.tab === Tab.Timeseries || target.tab === undefined) {\n      const query: DataQueryRequestItem = {\n        name: target.target,\n      };\n      return [query];\n    }\n\n    if (target.tab === Tab.Asset) {\n      await this.findAssetTimeseries(target, options);\n      return target.assetQuery.timeseries.filter(ts => ts.selected).map(ts => ({ name: ts.name }));\n    }\n\n    if (target.tab === Tab.Custom) {\n      await this.findAssetTimeseries(target, options);\n      // if we don't have any timeseries just return\n      if (cache.getTimeseries(options, target).length === 0) {\n        target.warning = '[WARNING] No timeseries found.';\n        return [];\n      }\n      if (!target.expr) return [];\n      // apply the search expression\n      try {\n        return parseExpression(\n          target.expr,\n          options,\n          cache.getTimeseries(options, target),\n          this.templateSrv,\n          target\n        );\n      } catch (e) {\n        target.error = e;\n        return [];\n      }\n    }\n\n    return [];\n  }\n\n  public async annotationQuery(options: AnnotationQueryOptions): Promise<AnnotationResponse[]> {\n    const { range, annotation } = options;\n    const { expr, filter, error } = annotation;\n    const startTime = Math.ceil(dateMath.parse(range.from));\n    const endTime = Math.ceil(dateMath.parse(range.to));\n    if (error || !expr) return [];\n\n    const queryOptions = parse(expr, ParseType.Event, this.templateSrv);\n    if (queryOptions.error) {\n      console.error(queryOptions.error);\n      return [];\n    }\n    const filterOptions = parse(filter || '', ParseType.Event, this.templateSrv);\n    if (filter && filterOptions.error) {\n      console.error(filterOptions.error);\n      return [];\n    }\n\n    // use maxStartTime and minEndTime so that we include events that are partially in range\n    const queryParams = {\n      limit: 1000,\n      maxStartTime: endTime,\n      minEndTime: startTime,\n      ...queryOptions.filters.reduce((obj, filter) => {\n        obj[filter.property] = filter.value;\n        return obj;\n      }, {}),\n    };\n\n    const result = await cache.getQuery(\n      {\n        url: `${this.url}/cogniteapi/${this.project}/events/search?${Utils.getQueryString(\n          queryParams\n        )}`,\n        method: 'GET',\n      },\n      this.backendSrv\n    );\n    const events = result.data.data.items;\n    if (!events || events.length === 0) return [];\n\n    Utils.applyFilters(filterOptions.filters, events);\n\n    return events\n      .filter(e => e.selected === true)\n      .map(event => ({\n        annotation,\n        isRegion: true,\n        text: event.description,\n        time: event.startTime,\n        timeEnd: event.endTime,\n        title: event.type,\n      }));\n  }\n\n  public async getOptionsForDropdown(\n    query: string,\n    type?: string,\n    options?: any\n  ): Promise<MetricFindQueryResponse> {\n    let urlEnd: string;\n    if (type === Tab.Asset) {\n      if (query.length === 0) {\n        urlEnd = `/cogniteapi/${this.project}/assets?`;\n      } else {\n        urlEnd = `/cogniteapi/${this.project}/assets/search?query=${query}`;\n      }\n    } else if (type === Tab.Timeseries) {\n      if (query.length === 0) {\n        urlEnd = `/cogniteapi/${this.project}/timeseries?`;\n      } else {\n        urlEnd = `/cogniteapi/${this.project}/timeseries/search?query=${query}`;\n      }\n    }\n    if (options) {\n      urlEnd += `&${Utils.getQueryString(options)}`;\n    }\n\n    return cache\n      .getQuery(\n        {\n          url: this.url + urlEnd,\n          method: 'GET',\n        },\n        this.backendSrv\n      )\n      .then((result: { data: TimeSeriesResponse }) =>\n        result.data.data.items.map(timeSeriesResponseItem => ({\n          text: timeSeriesResponseItem.description\n            ? `${timeSeriesResponseItem.name} (${timeSeriesResponseItem.description})`\n            : timeSeriesResponseItem.name,\n          value:\n            type === Tab.Asset ? String(timeSeriesResponseItem.id) : timeSeriesResponseItem.name,\n        }))\n      );\n  }\n\n  async findAssetTimeseries(target: QueryTarget, options: QueryOptions): Promise<void> {\n    // replace variables with their values\n    const assetId = this.templateSrv.replace(target.assetQuery.target, options.scopedVars);\n    const searchQuery: Partial<TimeseriesSearchQuery> = {\n      path: target.assetQuery.includeSubtrees ? [assetId] : undefined,\n      assetId: !target.assetQuery.includeSubtrees ? assetId : undefined,\n      limit: 10000,\n    };\n\n    // for custom queries, use cache instead of storing in target object\n    if (target.tab === Tab.Custom) {\n      target.assetQuery.templatedTarget = assetId;\n      const timeseries = cache.getTimeseries(options, target);\n      if (!timeseries) {\n        const ts = await this.getTimeseries(searchQuery, target);\n        cache.setTimeseries(\n          options,\n          target,\n          ts.map(ts => {\n            ts.selected = true;\n            return ts;\n          })\n        );\n      }\n      return Promise.resolve();\n    }\n\n    // check if assetId has changed, if not we do not need to perform this query again\n    if (\n      target.assetQuery.old &&\n      assetId === target.assetQuery.old.target &&\n      target.assetQuery.includeSubtrees === target.assetQuery.old.includeSubtrees\n    ) {\n      return Promise.resolve();\n    }\n    target.assetQuery.old = {\n      target: String(assetId),\n      includeSubtrees: target.assetQuery.includeSubtrees,\n    };\n\n    // since /dataquery can only have 100 items and checkboxes become difficult to use past 100 items,\n    //  we only get the first 100 timeseries, and show a warning if there are too many timeseries\n    searchQuery.limit = 101;\n    const ts = await this.getTimeseries(searchQuery, target);\n    if (ts.length === 101) {\n      target.warning =\n        \"[WARNING] Only showing first 100 timeseries. To get better results, either change the selected asset or use 'Custom Query'.\";\n      ts.splice(-1);\n    }\n    target.assetQuery.timeseries = ts.map(ts => {\n      ts.selected = true;\n      return ts;\n    });\n  }\n\n  async getTimeseries(\n    searchQuery: Partial<TimeseriesSearchQuery>,\n    target: QueryTarget\n  ): Promise<TimeSeriesResponseItem[]> {\n    return cache\n      .getQuery(\n        {\n          url: `${this.url}/cogniteapi/${this.project}/timeseries?${Utils.getQueryString(\n            searchQuery\n          )}`,\n          method: 'GET',\n        },\n        this.backendSrv\n      )\n      .then(\n        (result: { data: TimeSeriesResponse }) => {\n          return _.cloneDeep(result.data.data.items.filter(ts => !ts.isString));\n        },\n        error => {\n          if (error.data && error.data.error) {\n            target.error = `[${error.status} ERROR] ${error.data.error.message}`;\n          } else {\n            target.error = 'Unknown error';\n          }\n          return [];\n        }\n      );\n  }\n\n  // this function is for getting metrics (template variables)\n  async metricFindQuery(query: VariableQueryData): Promise<MetricFindQueryResponse> {\n    const queryOptions = parse(query.query, ParseType.Asset, this.templateSrv);\n    if (queryOptions.error) {\n      return [{ text: queryOptions.error, value: '-' }];\n    }\n    const filterOptions = parse(query.filter, ParseType.Asset, this.templateSrv);\n    if (query.filter && filterOptions.error) {\n      return [{ text: filterOptions.error, value: '-' }];\n    }\n    const urlEnd = `/cogniteapi/${this.project}/assets/search?`;\n\n    const queryParams = {\n      limit: 1000,\n      ...queryOptions.filters.reduce((obj, filter) => {\n        obj[filter.property] = filter.value;\n        return obj;\n      }, {}),\n    };\n\n    const result = await cache.getQuery(\n      {\n        url: this.url + urlEnd + Utils.getQueryString(queryParams),\n        method: 'GET',\n      },\n      this.backendSrv\n    );\n\n    const assets = result.data.data.items;\n\n    // now filter over these assets with the rest of the filters\n    Utils.applyFilters(filterOptions.filters, assets);\n    const filteredAssets = assets.filter(asset => asset.selected === true);\n\n    return filteredAssets.map(asset => ({\n      text: asset.name,\n      value: asset.id,\n    }));\n  }\n\n  private getTimeseriesLabel(label: string, timeseries: TimeSeriesResponseItem): string {\n    // matches with any text within {{ }}\n    const variableRegex = /{{([^{}]*)}}/g;\n    return label.replace(variableRegex, (full, group) => {\n      return _.get(timeseries, group, full);\n    });\n  }\n\n  testDatasource() {\n    return this.backendSrv\n      .datasourceRequest({\n        url: `${this.url}/cogniteloginstatus`,\n        method: 'GET',\n      })\n      .then(response => {\n        if (response.status === 200) {\n          if (response.data.data.loggedIn && response.data.data.project === this.project) {\n            return {\n              status: 'success',\n              message: 'Your Cognite credentials are valid',\n              title: 'Success',\n            };\n          }\n          return {\n            status: 'error',\n            message: 'Your Cognite credentials are invalid',\n            title: 'Error',\n          };\n        }\n      });\n  }\n}\n","import {\n  DataSourceRequestOptions,\n  isError,\n  TimeSeriesResponseItem,\n  QueryTarget,\n  QueryOptions,\n} from './types';\nimport { BackendSrv } from 'grafana/app/core/services/backend_srv';\nimport Utils from './utils';\n\n// Cache requests for 10 seconds\nconst cacheTime = 1000 * 10;\n\nconst queries = {\n  results: new Map(),\n  requests: new Map(),\n};\n\nexport const getQuery = async (query: DataSourceRequestOptions, backendSrv: BackendSrv) => {\n  const stringQuery = JSON.stringify(query);\n\n  if (queries.requests.has(stringQuery)) {\n    return queries.requests.get(stringQuery);\n  }\n  if (queries.results.has(stringQuery)) {\n    return queries.results.get(stringQuery);\n  }\n  const promise = backendSrv.datasourceRequest(query).then(\n    res => {\n      if (!res) {\n        // the item may not exist, or it may have been deleted\n        return {};\n      }\n      const asset = res;\n      if (!isError(asset)) {\n        queries.results.set(stringQuery, asset);\n        // set a timeout to clear the cache\n        setTimeout(() => {\n          queries.results.delete(stringQuery);\n          queries.requests.delete(stringQuery);\n        }, cacheTime);\n      }\n      queries.requests.delete(stringQuery);\n      return asset;\n    },\n    error => {\n      // clear the cache so that the request can be retried\n      queries.requests.delete(stringQuery);\n      // pass the error up to the caller\n      throw error;\n    }\n  );\n  queries.requests.set(stringQuery, promise);\n  return promise;\n};\n\nconst assetTimeseries = new Map<string, TimeSeriesResponseItem[]>();\n\nexport const getTimeseries = (options: QueryOptions, target: QueryTarget) => {\n  return assetTimeseries.get(Utils.timeseriesHash(options, target));\n};\n\nexport const setTimeseries = (\n  options: QueryOptions,\n  target: QueryTarget,\n  timeseries: TimeSeriesResponseItem[]\n) => {\n  assetTimeseries.set(Utils.timeseriesHash(options, target), timeseries);\n};\n\nconst cache = {\n  getQuery,\n  getTimeseries,\n  setTimeseries,\n};\n\nexport default cache;\n","import {\n  DataQueryRequestItem,\n  ParseType,\n  QueryOptions,\n  FilterOptions,\n  FilterType,\n  TimeSeriesResponseItem,\n  DataQueryAlias,\n  QueryTarget,\n} from './types';\nimport Utils from './utils';\nimport _ from 'lodash';\nimport { TemplateSrv } from 'grafana/app/features/templating/template_srv';\n\nexport const parseExpression = (\n  expr: string,\n  options: QueryOptions,\n  timeseries: TimeSeriesResponseItem[],\n  templateSrv: TemplateSrv,\n  target: QueryTarget\n): DataQueryRequestItem[] => {\n  const trimmedExpr = expr.trim();\n  // first check if it is just a simple `timeseries{}` or `timeseries{}[]`\n  if (isSimpleTimeseriesExpression(trimmedExpr)) {\n    const filterOptions = getAndApplyFilterOptions(trimmedExpr, templateSrv, options, timeseries);\n    target.aggregation = Utils.getAggregationDropdownString(filterOptions.aggregation);\n    target.granularity = filterOptions.granularity;\n    return timeseries.filter(ts => ts.selected).map(ts => ({ name: ts.name }));\n  }\n\n  const exprWithSpecialFunctions = parseSpecialFunctions(\n    trimmedExpr,\n    options,\n    timeseries,\n    templateSrv\n  );\n\n  return createDataQueryRequestItems(\n    exprWithSpecialFunctions,\n    options,\n    timeseries,\n    templateSrv,\n    ''\n  );\n};\n\nconst parseSpecialFunctions = (\n  expr: string,\n  options: QueryOptions,\n  timeseries: TimeSeriesResponseItem[],\n  templateSrv: TemplateSrv\n) => {\n  let newExpr = expr;\n  // look for sum(), max(), min(), or avg() with timeseries in it\n  const funcRegex = /(sum|max|min|avg)\\(timeseries.*?\\)/gi;\n  const funcRegexMatches = newExpr.match(funcRegex);\n  if (funcRegexMatches) {\n    for (const match of funcRegexMatches) {\n      // the match might match too much, so we need to parse the string more\n      const matchIndex = newExpr.indexOf(match);\n      if (matchIndex < 0) continue;\n      const timeseriesString = findTimeseriesString(newExpr.substr(matchIndex));\n      // make sure that we have func(timeseries{}[]) and not a use of the function eg max(timeseries{}, 0)\n      if (match.charAt(4 + timeseriesString.length) !== ')') continue;\n      const actualMatchString = `${match.substr(0, 4)}${timeseriesString})`;\n      const filterOptions = getAndApplyFilterOptions(\n        timeseriesString,\n        templateSrv,\n        options,\n        timeseries\n      );\n      const selectedTs = timeseries.filter(ts => ts.selected);\n      let funcString = '';\n      if (match.substr(0, 3).toLowerCase() === 'sum') {\n        funcString = `([${selectedTs\n          .map(ts => getTempAliasString(ts, filterOptions))\n          .join('] + [')}])`;\n      } else {\n        if (selectedTs.length <= 1) {\n          funcString = selectedTs.map(ts => `[${getTempAliasString(ts, filterOptions)}]`).join('');\n        } else {\n          funcString = `${match.slice(0, 3).toLowerCase()}([${selectedTs\n            .map(ts => getTempAliasString(ts, filterOptions))\n            .join('], [')}])`;\n        }\n      }\n      newExpr = newExpr.replace(actualMatchString, funcString);\n    }\n  }\n\n  return newExpr;\n};\n\n// recursively calls itself to create an array of DataQueryRequestItems\nconst createDataQueryRequestItems = (\n  expr: string,\n  options: QueryOptions,\n  timeseries: TimeSeriesResponseItem[],\n  templateSrv: TemplateSrv,\n  name: string\n): DataQueryRequestItem[] => {\n  let dataItems: DataQueryRequestItem[] = [];\n  // match timeseries{}[] or timeseries{}\n  const timeseriesString = findTimeseriesString(expr);\n  if (!timeseriesString) {\n    dataItems.push({\n      name,\n      function: expr,\n    });\n  } else {\n    const filterOptions = getAndApplyFilterOptions(\n      timeseriesString,\n      templateSrv,\n      options,\n      timeseries\n    );\n    const selectedTs = timeseries.filter(ts => ts.selected);\n\n    for (const ts of selectedTs) {\n      const replaceString = `[${getTempAliasString(ts, filterOptions)}]`;\n      let newExpr = expr.replace(timeseriesString, replaceString);\n\n      // we need to replace all similar timeseries requests\n      //  this is so that expressions like `timeseries{} - timeseries{}[avg]` work\n      // match all similar `timeseries{...}` and replace them\n      const tsFiltersString = findTimeseriesString(timeseriesString, false);\n      let index = newExpr.indexOf(tsFiltersString);\n      while (index >= 0) {\n        const similarTimeseriesString = findTimeseriesString(newExpr.substr(index));\n        const similarFilterOptions = getAndApplyFilterOptions(\n          similarTimeseriesString,\n          templateSrv,\n          options,\n          selectedTs\n        );\n        newExpr = newExpr.replace(\n          similarTimeseriesString,\n          `[${getTempAliasString(ts, similarFilterOptions)}]`\n        );\n        index = newExpr.indexOf(tsFiltersString);\n      }\n\n      dataItems = dataItems.concat(\n        createDataQueryRequestItems(newExpr, options, timeseries, templateSrv, name || ts.name)\n      );\n    }\n  }\n\n  return dataItems.map(item => {\n    updateAliases(item, options);\n    return item;\n  });\n};\n\nconst getAndApplyFilterOptions = (\n  timeseriesString: string,\n  templateSrv: TemplateSrv,\n  options: QueryOptions,\n  timeseries: TimeSeriesResponseItem[]\n) => {\n  const filterOptions = parse(timeseriesString, ParseType.Timeseries, templateSrv, options);\n  if (filterOptions.error) throw filterOptions.error;\n  Utils.applyFilters(filterOptions.filters, timeseries);\n  return filterOptions;\n};\n\n// puts in format: 'ID' or 'ID,aggr' or 'ID,aggr,gran'\nconst getTempAliasString = (timeseries: TimeSeriesResponseItem, filterOptions: FilterOptions) => {\n  return `${timeseries.id}${filterOptions.aggregation ? `,${filterOptions.aggregation}` : ''}${\n    filterOptions.granularity ? `,${filterOptions.granularity}` : ''\n  }`;\n};\n\nconst isSimpleTimeseriesExpression = (expr: string) => {\n  return findTimeseriesString(expr) === expr;\n};\n\n// finds and returns the first string of format 'timeseries{.*}' or 'timeseries{.*}[.*]', respecting brackets\nconst findTimeseriesString = (expr: string, withAggregateAndGranularity: boolean = true) => {\n  const timeseriesIndex = expr.indexOf('timeseries{');\n  if (timeseriesIndex < 0) return '';\n  const startIndex = timeseriesIndex + 'timeseries{'.length;\n  let openBracketCount = 1;\n  let index = 0;\n\n  while (openBracketCount > 0) {\n    if (startIndex + index >= expr.length) {\n      throw `ERROR: Unable to parse ${expr.substr(timeseriesIndex)}`;\n    }\n    if (expr.charAt(startIndex + index) === '{') openBracketCount += 1;\n    else if (expr.charAt(startIndex + index) === '}') openBracketCount -= 1;\n    else if (expr.charAt(startIndex + index) === '\"' || expr.charAt(startIndex + index) === \"'\") {\n      // skip ahead if we find a quote\n      const endQuote = expr.indexOf(expr.charAt(startIndex + index), startIndex + index + 1);\n      if (endQuote < 0) throw `ERROR: Unable to parse ${expr.substr(timeseriesIndex)}`;\n      index = endQuote - startIndex;\n    }\n    index += 1;\n  }\n  if (\n    withAggregateAndGranularity &&\n    startIndex + index < expr.length &&\n    expr.charAt(startIndex + index) === '['\n  ) {\n    const closeBracketIndex = expr.indexOf(']', startIndex + index);\n    if (closeBracketIndex > 0) index = closeBracketIndex - startIndex + 1;\n    else throw `ERROR: Unable to parse ${expr.substr(timeseriesIndex)}`;\n  }\n\n  return expr.substr(timeseriesIndex, index + 'timeseries{'.length);\n};\n\n// take in a dataqueryrequestitem and replace all [ID,agg] or [ID,agg,gran] with aliases\nconst updateAliases = (queryItem: DataQueryRequestItem, options: QueryOptions) => {\n  const regexSearch = /\\[.*?\\]/g;\n  const regexMatches = queryItem.function.match(regexSearch);\n  if (!queryItem.aliases) queryItem.aliases = [];\n  if (regexMatches) {\n    for (const match of regexMatches) {\n      // format is id, aggregation, granularity\n      const aliasParts = match\n        .substr(1, match.length - 2)\n        .split(',')\n        .filter(string => string.length)\n        .map(x => _.trim(x, ' \\'\"'));\n      // if we only get [ID] or [ALIAS], then there is no need to make an alias\n      if (aliasParts.length === 1) continue;\n      const alias: DataQueryAlias = {\n        alias: `alias${aliasParts.join('_')}`,\n        id: Number(aliasParts[0]),\n      };\n      alias.aggregate = aliasParts[1];\n      alias.granularity = aliasParts[2] || Utils.intervalToGranularity(options.intervalMs);\n      queryItem.function = queryItem.function.replace(match, `[${alias.alias}]`);\n      if (queryItem.aliases.find(x => x.alias === alias.alias)) continue;\n      queryItem.aliases.push(alias);\n    }\n  }\n};\n\nexport const parse = (\n  customQuery: string,\n  type: ParseType,\n  templateSrv: TemplateSrv,\n  options?: QueryOptions\n): FilterOptions => {\n  let query = customQuery;\n  if (type === ParseType.Timeseries || type === ParseType.Event) {\n    // replace variables with their values\n    if (options) {\n      query = templateSrv.replace(query, options.scopedVars);\n    } else {\n      for (const templateVariable of templateSrv.variables) {\n        query = query.replace(`[[${templateVariable.name}]]`, templateVariable.current.value);\n        query = query.replace(`$${templateVariable.name}`, templateVariable.current.value);\n      }\n    }\n  }\n\n  const filtersOptions = {\n    filters: [],\n    granularity: '',\n    aggregation: '',\n    error: '',\n  };\n\n  // Format: timeseries{ options }\n  //     or  timeseries{ options }[aggregation, granularity]\n  // regex pulls out the options string, as well as the aggre/gran string (if it exists)\n  const timeseriesRegex = /^timeseries\\{(.*)\\}(?:\\[(.*)\\])?$/;\n  const timeseriesMatch = query.match(timeseriesRegex);\n  const assetRegex = /^(?:asset|event)\\{(.*)\\}$/;\n  const assetMatch = query.match(assetRegex);\n  const filterRegex = /^filter\\{(.*)\\}$/;\n  const filterMatch = query.match(filterRegex);\n\n  let splitfilters: string[];\n  if (timeseriesMatch) {\n    // regex finds commas that are not followed by a closed bracket\n    splitfilters = Utils.splitFilters(timeseriesMatch[1], filtersOptions, false);\n  } else if (assetMatch) {\n    splitfilters = Utils.splitFilters(assetMatch[1], filtersOptions, true);\n  } else if (filterMatch) {\n    splitfilters = Utils.splitFilters(filterMatch[1], filtersOptions, false);\n  } else {\n    filtersOptions.error = `ERROR: Unable to parse expression ${query}`;\n  }\n\n  if (filtersOptions.error) {\n    return filtersOptions;\n  }\n\n  for (let f of splitfilters) {\n    f = _.trim(f, ' ');\n    if (f === '') continue;\n    const filter: any = {};\n    let i: number;\n    if ((i = f.indexOf(FilterType.RegexEquals)) > -1) {\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\n      filter.value = _.trim(f.substr(i + 2), ' \\'\"');\n      filter.type = FilterType.RegexEquals;\n    } else if ((i = f.indexOf(FilterType.RegexNotEquals)) > -1) {\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\n      filter.value = _.trim(f.substr(i + 2), ' \\'\"');\n      filter.type = FilterType.RegexNotEquals;\n    } else if ((i = f.indexOf(FilterType.NotEquals)) > -1) {\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\n      filter.value = _.trim(f.substr(i + 2), ' \\'\"');\n      filter.type = FilterType.NotEquals;\n    } else if ((i = f.indexOf(FilterType.Equals)) > -1) {\n      filter.property = _.trim(f.substr(0, i), ' \\'\"');\n      filter.value = _.trim(f.substr(i + 1), ' \\'\"');\n      filter.type = FilterType.Equals;\n    } else {\n      console.error(`Error parsing ${f}`);\n    }\n    filtersOptions.filters.push(filter);\n  }\n\n  if (timeseriesMatch) {\n    const aggregation = timeseriesMatch[2];\n    if (aggregation) {\n      const splitAggregation = aggregation.split(',');\n      filtersOptions.aggregation = _.trim(splitAggregation[0], ' \\'\"').toLowerCase();\n      filtersOptions.granularity =\n        splitAggregation.length > 1 ? _.trim(splitAggregation[1], ' \\'\"') : '';\n    }\n  }\n\n  return filtersOptions;\n};\n","import _ from 'lodash';\nimport { QueryCtrl } from 'grafana/app/plugins/sdk';\nimport './css/query_editor.css';\nimport CogniteDatasource from './datasource';\nimport { Tab, QueryTarget, TimeSeriesResponseItem } from './types';\n\nexport class CogniteQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  target: QueryTarget;\n  assetVals: any;\n  datasource: CogniteDatasource;\n  panelCtrl: any;\n  aggregation = [\n    { value: 'none', name: 'None' },\n    { value: 'average', name: 'Average' },\n    { value: 'max', name: 'Max' },\n    { value: 'min', name: 'Min' },\n    { value: 'count', name: 'Count' },\n    { value: 'sum', name: 'Sum' },\n    { value: 'interpolation', name: 'Interpolation' },\n    { value: 'stepInterpolation', name: 'Step Interpolation' },\n    { value: 'continuousVariance', name: 'Continuous Variance' },\n    { value: 'discreteVariance', name: 'Discrete Variance' },\n    { value: 'totalVariation', name: 'Total Variation' },\n  ];\n  tabs = [\n    {\n      value: Tab.Timeseries,\n      name: 'Select Timeseries',\n      src: 'timeseriestab.html',\n    },\n    {\n      value: Tab.Asset,\n      name: 'Select Timeseries from Asset',\n      src: 'assettab.html',\n    },\n    { value: Tab.Custom, name: 'Custom Query', src: 'customtab.html' },\n  ];\n  currentTabIndex: number;\n  defaults = {\n    target: 'Start typing tag id here',\n    type: 'timeserie',\n    aggregation: 'average',\n    granularity: '',\n    label: '',\n    tab: Tab.Timeseries,\n    expr: '',\n    assetQuery: {\n      target: '',\n      old: undefined,\n      timeseries: [],\n      includeSubtrees: false,\n      func: '',\n      templatedTarget: '',\n    },\n  };\n  isAllSelected: boolean;\n\n  /** @ngInject **/\n  constructor($scope, $injector, private templateSrv) {\n    super($scope, $injector);\n\n    _.defaultsDeep(this.target, this.defaults);\n\n    this.currentTabIndex = this.tabs.findIndex(x => x.value === this.target.tab) || 0;\n    if (this.target.tab !== Tab.Asset) {\n      this.target.assetQuery.timeseries = [];\n      this.target.assetQuery.old = undefined;\n    }\n    this.isAllSelected =\n      this.target.assetQuery.timeseries &&\n      this.target.assetQuery.timeseries.every(ts => ts.selected);\n  }\n\n  getOptions(query: string, type: string) {\n    return this.datasource.getOptionsForDropdown(query || '', type).then(options => {\n      _.defer(() => this.$scope.$digest()); // need to force the update on the dropdown\n      return options;\n    });\n  }\n\n  onChangeInternal() {\n    this.refresh(); // Asks the panel to refresh data.\n  }\n\n  changeTab(index: number) {\n    this.currentTabIndex = index;\n    this.target.tab = this.tabs[index].value;\n    this.refresh();\n  }\n\n  toggleCheckboxes() {\n    this.isAllSelected = !this.isAllSelected;\n    this.target.assetQuery.timeseries.forEach(ts => (ts.selected = this.isAllSelected));\n  }\n\n  selectOption(timeseries: TimeSeriesResponseItem) {\n    timeseries.selected = !timeseries.selected;\n    this.isAllSelected = this.target.assetQuery.timeseries.every(ts => ts.selected);\n  }\n\n  getCollapsedText() {\n    if (this.target.tab === Tab.Timeseries) {\n      return `Timeseries: ${this.target.target} ${this.target.error}`;\n    }\n    if (this.target.tab === Tab.Asset) {\n      return `Timeseries from Asset: ${this.target.assetQuery.target} ${this.target.error}`;\n    }\n    if (this.target.tab === Tab.Custom) {\n      return `Custom Query: ${this.target.expr} ${this.target.error}`;\n    }\n    return '';\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","\nvar content = require(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/dist/cjs.js??ref--5-1!./query_editor.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/dist/runtime/api.js\")(true);\n// Module\nexports.push([module.id, \".min-width-10 {\\n  min-width: 10rem;\\n}\\n\\n.min-width-12 {\\n  min-width: 12rem;\\n}\\n\\n.min-width-20 {\\n  min-width: 20rem;\\n}\\n\\n.gf-form-select-wrapper select.gf-form-input {\\n  height: 2.64rem;\\n}\\n\\n.gf-form-select-wrapper--caret-indent.gf-form-select-wrapper::after {\\n  right: 0.775rem;\\n}\\n\\n.gf-tabs-cognite.active:before,\\n.gf-tabs-cognite.active:focus:before,\\n.gf-tabs-cognite.active:hover:before {\\n  background-image: linear-gradient(90deg, #33b5e5 0, #00b3ff 99%, #1b1b1b);\\n}\\n\\ninput[type='checkbox'] {\\n  margin: 4px;\\n}\\n\\n.custom-query {\\n  font-family: monospace;\\n}\\n\\npre code {\\n  line-height: 2;\\n}\\n\\n.cognite-timeseries-list-checkbox {\\n  margin-right: 10px;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"query_editor.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,eAAe;AACjB;;AAEA;;;EAGE,yEAAyE;AAC3E;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,kBAAkB;AACpB\",\"file\":\"query_editor.css\",\"sourcesContent\":[\".min-width-10 {\\n  min-width: 10rem;\\n}\\n\\n.min-width-12 {\\n  min-width: 12rem;\\n}\\n\\n.min-width-20 {\\n  min-width: 20rem;\\n}\\n\\n.gf-form-select-wrapper select.gf-form-input {\\n  height: 2.64rem;\\n}\\n\\n.gf-form-select-wrapper--caret-indent.gf-form-select-wrapper::after {\\n  right: 0.775rem;\\n}\\n\\n.gf-tabs-cognite.active:before,\\n.gf-tabs-cognite.active:focus:before,\\n.gf-tabs-cognite.active:hover:before {\\n  background-image: linear-gradient(90deg, #33b5e5 0, #00b3ff 99%, #1b1b1b);\\n}\\n\\ninput[type='checkbox'] {\\n  margin: 4px;\\n}\\n\\n.custom-query {\\n  font-family: monospace;\\n}\\n\\npre code {\\n  line-height: 2;\\n}\\n\\n.cognite-timeseries-list-checkbox {\\n  margin-right: 10px;\\n}\\n\"]}]);\n\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","export class CogniteConfigCtrl {\n  static templateUrl = 'partials/config.html';\n  current: any;\n\n  /** @ngInject **/\n  constructor($scope) {}\n}\n","import { Annotation } from './types';\nimport Utils from './utils';\n\nexport class CogniteAnnotationsQueryCtrl {\n  public static templateUrl = 'partials/annotations.editor.html';\n  annotation: Annotation;\n\n  verify() {\n    // simple verification that the queries are in the right format\n    this.annotation.error = '';\n    const errorObj = { error: '' };\n\n    // check the query expression\n    if (!this.annotation.expr) {\n      this.annotation.error = `Error: Query expression required.`;\n    } else {\n      const match = this.annotation.expr.match(/^event\\{(.*)\\}$/);\n      if (!match) {\n        this.annotation.error = `Error: Unable to parse ${\n          this.annotation.expr\n        } | Expected format: event{param=value,...}`;\n      } else if (!Utils.splitFilters(match[1], errorObj, true)) {\n        this.annotation.error = `${errorObj.error} | Expected format: event{param=value,...}`;\n      }\n    }\n    // check the filter expression (if it exists)\n    if (!this.annotation.error && this.annotation.filter) {\n      const match = this.annotation.filter.match(/^filter\\{(.*)\\}$/);\n      if (!match) {\n        this.annotation.error = `Error: Unable to parse ${\n          this.annotation.filter\n        } | Expected format: filter{property [=|!=|=~|!~] value,...}`;\n      } else if (!Utils.splitFilters(match[1], errorObj, false)) {\n        this.annotation.error = `${\n          errorObj.error\n        } | Expected format: filter{property [=|!=|=~|!~] value,...}`;\n      }\n    }\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\nimport { VariableQueryData, VariableQueryProps } from './types';\n\nexport class CogniteVariableQueryCtrl extends React.PureComponent<\n  VariableQueryProps,\n  VariableQueryData\n> {\n  defaults: VariableQueryData = {\n    query: '',\n    filter: '',\n  };\n\n  constructor(props: VariableQueryProps) {\n    super(props);\n    this.state = Object.assign(this.defaults, this.props.query);\n  }\n\n  handleChange(event, prop: 'query' | 'filter') {\n    const state: any = {\n      [prop]: event.target.value,\n    };\n    this.setState(state);\n  }\n\n  handleBlur() {\n    this.props.onChange(this.state, this.state.query);\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"gf-form gf-form--grow\">\n          <span className=\"gf-form-label query-keyword fix-query-keyword width-10\">Query</span>\n          <input\n            type=\"text\"\n            className=\"gf-form-input\"\n            value={this.state.query}\n            onChange={e => this.handleChange(e, 'query')}\n            onBlur={e => this.handleBlur()}\n            placeholder=\"eg: asset{name='example', assetSubtrees=[123456789]}\"\n            required\n          />\n        </div>\n        <div className=\"gf-form gf-form--grow\">\n          <span className=\"gf-form-label query-keyword fix-query-keyword width-10\">Filter</span>\n          <input\n            type=\"text\"\n            className=\"gf-form-input\"\n            value={this.state.filter}\n            onChange={e => this.handleChange(e, 'filter')}\n            onBlur={e => this.handleBlur()}\n            placeholder=\"eg: filter{name=~'.*test.*', isStep=1, metadata.key1!=false}\"\n          />\n        </div>\n        <div className=\"gf-form--grow\">\n          <pre>\n            {`  Query for assets using the '/assets/search' endpoint\n    Format is asset{param=value,...}\n  Then, filter on these assets\n    Format is filter{property comparator value,...}\n    Comparator can be =, !=, =~, !~ `}\n          </pre>\n        </div>\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""}